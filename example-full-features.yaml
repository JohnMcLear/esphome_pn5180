# ESPHome PN5180 Enhanced - Full Features Example
# This config demonstrates all the new RF power and diagnostic features

esphome:
  name: pn5180-enhanced-demo
  friendly_name: PN5180 Enhanced Demo

esp32:
  board: esp32dev
  framework:
    type: arduino

logger:
  level: DEBUG

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

external_components:
  - source:
      type: git
      url: https://github.com/YOUR_USERNAME/esphome-pn5180-enhanced
    components: [pn5180]
    refresh: 1d

spi:
  clk_pin: GPIO18
  miso_pin: GPIO19
  mosi_pin: GPIO23

# PN5180 with ALL enhanced features
pn5180:
  id: nfc_reader
  cs_pin: GPIO5
  rst_pin: GPIO17
  busy_pin: GPIO16
  update_interval: 1s
  
  # ══════════════════════════════════════════════════════════════
  # NEW: RF Power Configuration
  # ══════════════════════════════════════════════════════════════
  
  # RF Power Level: 0-255 (default 200)
  # Higher = stronger field, longer range
  # 255 = maximum power for long-range ISO15693 tags
  rf_power_level: 255
  
  # RF Collision Avoidance (DPC - Dynamic Power Control)
  # Automatically adjusts RF power under detuned antenna conditions
  rf_collision_avoidance: true
  
  # Protocol Priority: Optimize for specific card type
  # Options: ISO14443A, ISO14443B, ISO15693, FELICA, AUTO
  # Use ISO15693 for longest range (vicinity cards)
  rf_protocol_priority: ISO15693
  
  # ══════════════════════════════════════════════════════════════
  # NEW: LPCD (Low-Power Card Detection)
  # ══════════════════════════════════════════════════════════════
  
  # Enable LPCD for battery-powered applications
  # Dramatically reduces power consumption when idle
  lpcd_enabled: true
  lpcd_interval: 100ms  # Check every 100ms in low-power mode
  
  # ══════════════════════════════════════════════════════════════
  # NEW: RF Diagnostics
  # ══════════════════════════════════════════════════════════════
  
  # Publish RF field quality metrics as sensors
  publish_diagnostics: true
  
  # AGC (Automatic Gain Control) - indicates RF field quality
  # Range: 10-4000 (higher = better signal)
  agc_sensor:
    name: "NFC AGC Level"
    id: nfc_agc
  
  # RF Field Strength indicator
  rf_field_sensor:
    name: "NFC Field Strength"
    id: nfc_field
  
  # Temperature monitoring (for thermal protection)
  # Auto-reduces RF power if temp > 70°C
  temperature_sensor:
    name: "NFC Module Temperature"
    id: nfc_temp
  
  # ══════════════════════════════════════════════════════════════
  # Health Check (existing feature, now enhanced)
  # ══════════════════════════════════════════════════════════════
  
  health_check_enabled: true
  health_check_interval: 30s  # More frequent for critical systems
  max_failed_checks: 2
  auto_reset_on_failure: true
  
  # ══════════════════════════════════════════════════════════════
  # Automation Triggers
  # ══════════════════════════════════════════════════════════════
  
  on_tag:
    - homeassistant.tag_scanned: !lambda 'return x;'
    - logger.log:
        format: "Tag detected: %s"
        args: ['x.c_str()']
  
  on_tag_removed:
    - logger.log:
        format: "Tag removed: %s"
        args: ['x.c_str()']

# Binary sensor for specific known tag
binary_sensor:
  - platform: pn5180
    pn5180_id: nfc_reader
    name: "Access Badge"
    uid: "E0-04-01-50-4D-8A-3C-5F"

# Text sensor shows last scanned tag UID
text_sensor:
  - platform: pn5180
    pn5180_id: nfc_reader
    name: "Last Scanned Tag"

# ══════════════════════════════════════════════════════════════
# Additional Diagnostic Sensors
# ══════════════════════════════════════════════════════════════

# Monitor RF field quality over time
sensor:
  # Template sensors for RF quality analysis
  - platform: template
    name: "NFC Field Quality"
    unit_of_measurement: "%"
    update_interval: 5s
    lambda: |-
      // AGC range 10-4000, convert to percentage
      if (id(nfc_agc).has_state()) {
        float agc = id(nfc_agc).state;
        return ((agc - 10.0) / 3990.0) * 100.0;
      }
      return 0.0;

  # Thermal throttle indicator
  - platform: template
    name: "NFC Thermal Throttle Active"
    update_interval: 5s
    lambda: |-
      if (id(nfc_temp).has_state()) {
        return id(nfc_temp).state > 70.0 ? 1.0 : 0.0;
      }
      return 0.0;
